    if(color == SmootherColor::Black) { \
        /* -------------------- */ \
        /* Node in the interior */ \
        /* -------------------- */ \
        if(i_r > 0 && i_r < grid.numberSmootherCircles()){ \
            double h1 = grid.r_dist(i_r-1); \
            double h2 = grid.r_dist(i_r); \
            double k1 = grid.theta_dist(i_theta-1); \
            double k2 = grid.theta_dist(i_theta); \
            double coeff1 = 0.5*(k1+k2)/h1; \
            double coeff2 = 0.5*(k1+k2)/h2; \
            double coeff3 = 0.5*(h1+h2)/k1; \
            double coeff4 = 0.5*(h1+h2)/k2; \
            if(node_color == SmootherColor::Black) { \
                /* ----------- */ \
                /* Take values */ \
                /* ----------- */ \
                /* Fill result of (i,j) */ \
                rhs[grid.index(i_r,i_theta)] += \
                    0.25 * (h1+h2)*(k1+k2) * system_parameters.rhs_f(r, theta, sin_theta, cos_theta) * fabs(detDF); \
                /* Fill result(i,j) */ \
                rhs[grid.index(i_r,i_theta)] += factor * ( \
                    - coeff1 * arr * x[grid.index(i_r-1,i_theta)] /* Left */ \
                    - coeff2 * arr * x[grid.index(i_r+1,i_theta)] /* Right */ \
                ); \
                /* Fill result(i,j-1) */ \
                rhs[grid.index(i_r,i_theta-1)] += factor * ( \
                    - 0.25 * art * x[grid.index(i_r+1,i_theta)] /* Top Right */ \
                    + 0.25 * art * x[grid.index(i_r-1,i_theta)] ); /* Top Left */ \
                /* Fill result(i,j+1) */ \
                rhs[grid.index(i_r,i_theta+1)] += factor * ( \
                    + 0.25 * art * x[grid.index(i_r+1,i_theta)] /* Bottom Right */ \
                    - 0.25 * art * x[grid.index(i_r-1,i_theta)] ); /* Bottom Left */ \
            } \
            else if(node_color == SmootherColor::White) { \
                /* ----------- */ \
                /* Give values */ \
                /* ----------- */ \

            } \
        /* -------------------------- */ \
        /* Node on the inner boundary */ \
        /* -------------------------- */ \
        } else if (i_r == 0) { \
            /* ------------------------------------------------ */ \
            /* Case 1: Dirichlet boundary on the inner boundary */ \
            /* ------------------------------------------------ */ \
            if(DirBC_Interior){ \
                /* Take values */ \
                if(node_color == SmootherColor::Black) { \
                    /* Fill result of (i,j) */ \
                    rhs[grid.index(i_r,i_theta)] += \
                        system_parameters.u_D_Interior(r, theta, sin_theta, cos_theta); \
                } \
            } else{ \
                /* ------------------------------------------------------------- */ \
                /* Case 2: Across origin discretization on the interior boundary */ \
                /* ------------------------------------------------------------- */ \
                /* h1 gets replaced with 2 * R0. */ \
                /* (i_r-1,i_theta) gets replaced with (i_r, i_theta + (grid.ntheta()>>1)). */ \
                /* Some more adjustments from the changing the 9-point stencil to the artifical 7-point stencil. */ \
                double h1 = 2 * grid.radius(0); \
                double h2 = grid.r_dist(i_r); \
                double k1 = grid.theta_dist(i_theta-1); \
                double k2 = grid.theta_dist(i_theta); \
                double coeff1 = 0.5*(k1+k2)/h1; \
                double coeff2 = 0.5*(k1+k2)/h2; \
                double coeff3 = 0.5*(h1+h2)/k1; \
                double coeff4 = 0.5*(h1+h2)/k2; \
                /* Take values */ \
                if(node_color == SmootherColor::Black) { \
                    /* Fill result of (i,j) */ \
                    result[grid.index(i_r,i_theta)] += \
                        0.25 * (h1+h2)*(k1+k2) * system_parameters.rhs_f(r, theta, sin_theta, cos_theta) * fabs(detDF); \
                    /* Fill result(i,j) */ \
                    result[grid.index(i_r,i_theta)] += factor * ( \
                        - coeff1 * arr * x[grid.index(i_r, i_theta + (grid.ntheta()>>1))] /* Left */ \
                        - coeff2 * arr * x[grid.index(i_r+1,i_theta)] /* Right */ \
                    ); \
                    /* Fill result(i,j-1) */ \
                    result[grid.index(i_r,i_theta-1)] += factor * ( \
                        - 0.25 * art * x[grid.index(i_r+1,i_theta)] ); /* Top Right */ \
                    /* Fill result(i,j+1) */ \
                    result[grid.index(i_r,i_theta+1)] += factor * ( \
                        + 0.25 * art * x[grid.index(i_r+1,i_theta)] ); /* Bottom Right */ \
                } \
            } \
        } \
        else if(i_r == grid.numberSmootherCircles()) {} /* Do noting */ \
    } \